<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <title>gameName</title> <style> *{ margin: 0; padding: 0; } canvas { border: 1px solid #a1a1a1; } </style> </head> <body> <canvas id="js-game" width=300 height=160 tabindex="0"></canvas> </body> </html><script> class Transpiler { compile(object, runtime) { const code = object.code.replace(/ /g, ""); const lines = code.split("\n"); for (let i = 0; i < lines.length; i++) { if (lines[i].slice(0, 2) === "##") { const line = lines[i].replace(/##/, ""); try { new Function(line)(); } catch (e) { console.error(new ErrorMessage(i).onJSInvalidLine(line, e)); } } else { const line = lines[i].split("->").map(param => param === "" ? void 0 : param);  let params = line[1] ? line[1].includes(",") ? line[1].split(",").map(param => isNaN(Number(param)) ? param : parseFloat(param)) : line[1] : void 0; const callError = e => { if (lines[i] !== "") { runtime.clearIntervals(); throw new ErrorMessage(i).onInvalidLine(line, e); } }; try { const listenerFactory = listener => { const listeners = { "onKey": "keypress", "onKeyRelease": "keyup", }; Canvas.get().elem.addEventListener(listeners[listener], e => { const key = e.key.replace(/ /, "space").toLowerCase(); if (key === line[3].toLowerCase()) { GMCLang[line[0]](object, params); } }); }; const callbacks = { "onKey|onKeyRelease": (param) => { listenerFactory(param); }, undefined: () => { gameIntervals.push(setInterval(() => { try { GMCLang[line[0]](object, params); } catch (e) { callError(e); } }, 20)); } }; callbacks[Object.keys(callbacks).filter(query => query.includes(line[2]))[0]](line[2]); } catch (e) { callError(e); } } } } }</script><script> class ImageParser { parse(obj, instance) { const { instances, img, width, height } = obj; const ins = instances[instance]; const shapes = { rect: () => { Canvas.get().context.fillRect(ins.x, ins.y, width, height); }, circle: () => { const w = width / 2; Canvas.get().context.beginPath(); Canvas.get().context.arc(ins.x + w, ins.y + w, w,0,2 * Math.PI); Canvas.get().context.fill(); Canvas.get().context.closePath(); } }; const command = "draw"; let image = img.replace(/ /g, ""); if (image.includes(command)) { image = image.toLowerCase() .replace(new RegExp(`${command}(->|::)`, "g"), "") .split(","); Canvas.get().context.fillStyle = image[1] ? image[1] : "#000"; shapes[image[0]](); } else { const image = new Image(0, 0); image.onload = () => { Canvas.get().context.drawImage(image, ins.x, ins.y); }; image.src = img; } } }</script><script> const GMCLang = {  moveToPoint: (object, params) => { object.instances.map(instance => instance.moveToPoint(...params)); }, moveToRelative: (object, params) => { object.instances.map(instance => instance.moveToRelative(...params)); }, checkWrapping: (object, param) => { object.instances.map(instance => instance.checkWrapping(param)); }, collision: (object, target) => { object.instances.map(instance => instance.collision(target)); }, jump: (object, params) => { object.instances.map(instance => instance.jump(...params)); }, }; GMCLang;</script><script> class ErrorMessage { constructor(lineNum = -2) { this.lineNum = lineNum; this.core = `Error occurred while parsing line number ${this.lineNum + 1}`; } onInvalidLine(line, dump) { return `${this.core} - this line has an incorrect statement: ${line}\n\n${dump}`; } onJSInvalidLine(line, dump) { return `${this.core} - illegal JavaScript snippet:\n\n${line}\n\n${dump}`; } onInstanceCreationFail(dump) { return `Instance cannot be created: \n\n${dump}`; } DOMInvalidElement(params) { let len = ""; try { len = `with length ${params[1].length}`; } catch {} return `Following element selector ${params[0]} returned ${params[1]} ${len}`; } onInvalidInput(dump) { return `Cannot get data from input: ${dump}`; } onCodeBindFail(obj, dump) { return `Cannot bind code to object of ${obj}:\n ${dump}`; } }</script><script> class Canvas { static get() { const canvas = document.getElementById("js-game"); return { elem: canvas, width: parseInt(canvas.width), height: parseInt(canvas.height), setWidth: (width) => { canvas.width = width }, setHeight: (height) => { canvas.height = height }, context: canvas.getContext("2d") } } } </script><script> Object.prototype.moveToRelative = function(x, y) { this.x += x; this.y += y; }; Object.prototype.moveToPoint = function(x, y) { this.x = x; this.y = y; }; Object.prototype.checkWrapping = function(mode = "both") { const checkCoords = (coord, canvasSize, objSize) => { let val = coord; if (coord > canvasSize + (objSize / 3)) { val = -objSize; } else if (coord < -objSize) { val = canvasSize; } return val; }; const wrap = { both: () => { wrap["horizontal"](); wrap["vertical"](); }, horizontal: () => { this.x = checkCoords(this.x, Canvas.get().width, this.width); }, vertical: () => { this.y = checkCoords(this.y, Canvas.get().height, this.height); } }; wrap[mode](); }; Object.prototype.jump = function(force, coord) { coord = isNaN(coord) || !coord ? "y" : coord; if (this.col) { const jmp = setInterval(() => { this[coord] += force / Math.atan(.4); force -= 0.001; if (force <= 0) { clearInterval(jmp); } }, 100); } this.col = false; }; Object.prototype.collision = function (target) { const checkCoords = (coord, objSize, instance) => { return { condition: this[coord] + this[objSize] > instance[coord] && instance[coord] + instance[objSize] > this[coord], newPosition: { first: instance[coord] + instance[objSize] - this[coord], second: this[coord] + this[objSize] - instance[coord] } }; }; const setPosition = obj => { const { first, second } = obj; return first < second ? first : -second; }; objects[target].instances.forEach(targetInstance => { const w = checkCoords("x", "width", targetInstance); const h = checkCoords("y", "height", targetInstance); if (w.condition && h.condition) { if (w.newPosition.first < h.newPosition.first || w.newPosition.second < h.newPosition.second) { this.x += setPosition(w.newPosition); } else { this.y += setPosition(h.newPosition); } this.col = true; } else { setTimeout(() => { this.col = false }, 25); } }); }; </script><script> class Runtime { constructor(release) { window.objects={"player":{"width":48,"height":48,"code":"moveToRelative->0,4->->\njump->-40,y->onKey->W\ncollision->wall->->\nmoveToRelative->-10,0->onKey->A\nmoveToRelative->10,0->onKey->D\ncheckWrapping->both->->\n","img":"draw->circle,green","instances":[{"x":115,"y":202,"width":48,"height":48,"col":true}]},"wall":{"width":265,"height":48,"code":"","img":"draw->rect","instances":[{"x":0,"y":250,"width":265,"height":48,"col":false},{"x":320,"y":280,"width":265,"height":48,"col":false}]}}; window.game={"name":"Platform_example","width":640,"height":360,"score":0}; window.gameIntervals = []; if (release) { this.build(); this.redraw(); } } build() { this.clearIntervals(); const objs = Object.keys(objects); objs.forEach(obj => { new Transpiler().compile(objects[obj], this); }); document.title = game.name ? game.name : "GM::Creator"; Canvas.get().setWidth(game.width); Canvas.get().setHeight(game.height); this.redraw(); } clearIntervals() { gameIntervals.forEach(interval => clearInterval(interval)); window.gameIntervals = []; } redraw() { requestAnimationFrame(() => this.render()); } render() { Canvas.get().context.clearRect(0, 0, Canvas.get().width, Canvas.get().height); Object.values(objects).forEach(object => { for (let i = 0; i < object.instances.length; i++) { new ImageParser().parse(object, i); } }); this.redraw(); } } </script><script> const release=true; const runtime = new Runtime(release); </script>